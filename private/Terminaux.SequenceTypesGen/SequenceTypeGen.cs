//
// Terminaux  Copyright (C) 2023-2025  Aptivi
//
// This file is part of Terminaux
//
// Terminaux is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Terminaux is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY, without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Terminaux.SequenceTypesGen.Decoy;

namespace Terminaux.SequenceTypesGen
{
    [Generator]
    public class SequenceTypeGen : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Get the color data content
            var asm = typeof(SequenceTypeGen).Assembly;
            var stream = asm.GetManifestResourceStream($"{asm.GetName().Name}.Resources.sequences.json");
            using var reader = new StreamReader(stream);
            string content = reader.ReadToEnd();

            // Read all the console sequences data
            var list = JsonConvert.DeserializeObject<SequenceTypeInfo[]>(content);
            if (list is null)
                return;
            SequencesEnumGenerator(list, context);
            SequencesClassGenerator(list, context);
            SequencesDictionaryGenerator(list, context);
        }

        private void SequencesEnumGenerator(SequenceTypeInfo[] list, IncrementalGeneratorInitializationContext context)
        {
            string header =
                $$"""
                //
                // Terminaux  Copyright (C) 2023-2025  Aptivi
                //
                // This file is part of Terminaux
                //
                // Terminaux is free software: you can redistribute it and/or modify
                // it under the terms of the GNU General Public License as published by
                // the Free Software Foundation, either version 3 of the License, or
                // (at your option) any later version.
                //
                // Terminaux is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY, without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                //
                // You should have received a copy of the GNU General Public License
                // along with this program.  If not, see <https://www.gnu.org/licenses/>.
                //
                
                // <auto-generated/>
                                
                namespace Terminaux.Sequences.Builder
                {
                    /// <summary>
                    /// Specific VT sequences sorted by type
                    /// </summary>
                    public enum VtSequenceSpecificTypes
                    {
                
                """;
            string footer =
                $$"""
                    }
                }
                """;
            var builder = new StringBuilder(header);

            // Populate the sequence class for every type
            for (int typeIdx = 0; typeIdx < list.Length; typeIdx++)
            {
                SequenceTypeInfo typeInfo = list[typeIdx];
                string typeNameUpper = typeInfo.Type.ToUpper();
                var seqs = typeInfo.Sequences;

                // Populate the sequence generation methods
                for (int seqIdx = 0; seqIdx < seqs.Length; seqIdx++)
                {
                    Sequence seq = seqs[seqIdx];
                    string seqName = seq.Name;

                    // Build the enum values
                    builder.AppendLine(
                        $$"""
                                /// <summary>
                                /// {{typeNameUpper}} VT sequence ({{seqName}})
                                /// </summary>
                                {{seqName}},
                        """
                    );
                }
            }

            // Add the footer
            builder.AppendLine(footer);
            context.RegisterPostInitializationOutput(ctx =>
            {
                ctx.AddSource("VtSequenceSpecificTypes.cs", SourceText.From(builder.ToString(), Encoding.UTF8));
            });
        }

        private void SequencesClassGenerator(SequenceTypeInfo[] list, IncrementalGeneratorInitializationContext context)
        {
            string header =
                $$"""
                //
                // Terminaux  Copyright (C) 2023-2025  Aptivi
                //
                // This file is part of Terminaux
                //
                // Terminaux is free software: you can redistribute it and/or modify
                // it under the terms of the GNU General Public License as published by
                // the Free Software Foundation, either version 3 of the License, or
                // (at your option) any later version.
                //
                // Terminaux is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY, without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                //
                // You should have received a copy of the GNU General Public License
                // along with this program.  If not, see <https://www.gnu.org/licenses/>.
                //
                
                // <auto-generated/>
                                
                using Terminaux.Base;
                using Terminaux.Sequences;

                namespace Terminaux.Sequences.Builder.Types
                {

                """;
            string footer =
                $$"""
                    }
                }
                """;

            // Populate the sequence class for every type
            foreach (var typeInfo in list)
            {
                var builder = new StringBuilder(header);
                string typeName = typeInfo.Type;
                string typeNameUpper = typeName.ToUpper();
                var seqs = typeInfo.Sequences;

                // Add the class declaration
                builder.AppendLine(
                    $$"""
                        /// <summary>
                        /// List of {{typeNameUpper}} sequences
                        /// </summary>
                        public static class {{typeName}}Sequences
                        {
                    """
                );

                // Populate the sequence generation methods
                for (int seqIdx = 0; seqIdx < seqs.Length; seqIdx++)
                {
                    Sequence seq = seqs[seqIdx];
                    string seqName = seq.Name;
                    string seqFormat = seq.Format;

                    // Populate the arguments
                    var seqParams = seq.Arguments;
                    var seqParamsBuilder = new StringBuilder();
                    for (int i = 0; i < seqParams.Length; i++)
                    {
                        Argument seqParam = seqParams[i];
                        string name = seqParam.Name;
                        string type =
                            seqParam.Type == "System.Int32" ? "int" :
                            seqParam.Type == "System.Char" ? "char" :
                            "string";
                        seqParamsBuilder.Append($"{type} {name}");
                        if (i < seqParams.Length - 1)
                            seqParamsBuilder.Append(", ");
                        seqFormat = seqFormat.Replace($"{{{{{i}}}}}", $"{{{name}}}");
                    }

                    // Build the generation method
                    builder.AppendLine(
                        $$"""
                                /// <summary>
                                /// Generates an escape sequence of type {{typeNameUpper}} with action {{seqName}}
                                /// </summary>
                                public static string Generate{{seqName}}({{seqParamsBuilder}})
                                {
                                    string result = $"{{seqFormat}}";
                                    var regexParser = {{seqName}}SequenceRegex;
                                    if (!regexParser.IsMatch(result))
                                        throw new TerminauxException(LanguageTools.GetLocalized("T_SEQUENCES_BUILDER_EXCEPTION_GENERATIONFAILED"), "{{typeNameUpper}}", "{{seqName}}");
                                    return result;
                                }
                        """
                    );
                    if (seqIdx < seqParams.Length - 1)
                        builder.AppendLine();
                }

                // Add the footer
                builder.AppendLine(footer);
                context.RegisterPostInitializationOutput(ctx =>
                {
                    ctx.AddSource($"{typeName}Sequences.cs", SourceText.From(builder.ToString(), Encoding.UTF8));
                });
            }
        }

        private void SequencesDictionaryGenerator(SequenceTypeInfo[] list, IncrementalGeneratorInitializationContext context)
        {
            string header =
                $$"""
                //
                // Terminaux  Copyright (C) 2023-2025  Aptivi
                //
                // This file is part of Terminaux
                //
                // Terminaux is free software: you can redistribute it and/or modify
                // it under the terms of the GNU General Public License as published by
                // the Free Software Foundation, either version 3 of the License, or
                // (at your option) any later version.
                //
                // Terminaux is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY, without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                //
                // You should have received a copy of the GNU General Public License
                // along with this program.  If not, see <https://www.gnu.org/licenses/>.
                //
                
                // <auto-generated/>
                                
                using System;
                using System.Collections.Generic;
                using Terminaux.Sequences.Builder.Types;

                namespace Terminaux.Sequences.Builder
                {
                    /// <summary>
                    /// VT sequence builder tools
                    /// </summary>
                    public static partial class VtSequenceBuilderTools
                    {
                        private static readonly Dictionary<VtSequenceSpecificTypes, (Delegate generator, int argumentsRequired, VtSequenceType sequenceType)> sequenceBuilders = new()
                        {
                
                """;
            string footer =
                $$"""
                            return generator.DynamicInvoke(arguments).ToString();
                        }
                    }
                }
                """;
            var builder = new StringBuilder(header);
            List<string> processedDelegates = [];

            // Populate the sequence class for every type
            for (int typeIdx = 0; typeIdx < list.Length; typeIdx++)
            {
                SequenceTypeInfo typeInfo = list[typeIdx];
                string typeName = typeInfo.Type;
                string typeNameUpper = typeName.ToUpper();
                var seqs = typeInfo.Sequences;
                builder.AppendLine(
                    $$"""
                                // {{typeNameUpper}} sequences
                    """
                );

                // Populate the sequence generation methods
                for (int seqIdx = 0; seqIdx < seqs.Length; seqIdx++)
                {
                    Sequence seq = seqs[seqIdx];
                    string seqName = seq.Name;

                    // Populate the arguments
                    var seqParams = seq.Arguments;
                    var seqParamsBuilder = new StringBuilder();
                    for (int i = 0; i < seqParams.Length; i++)
                    {
                        Argument seqParam = seqParams[i];
                        string type =
                            seqParam.Type == "System.Int32" ? "int" :
                            seqParam.Type == "System.Char" ? "char" :
                            "string";
                        seqParamsBuilder.Append($"{type}");
                        seqParamsBuilder.Append(", ");
                    }

                    // Build the dictionary entry
                    string processedDelegate = $"Func<{seqParamsBuilder}string>";
                    if (!processedDelegates.Contains(processedDelegate))
                        processedDelegates.Add(processedDelegate);
                    builder.AppendLine(
                        $$"""
                                    { VtSequenceSpecificTypes.{{seqName}},
                                        (new Func<{{seqParamsBuilder}}string>({{typeName}}Sequences.Generate{{seqName}}), {{seqParams.Length}}, VtSequenceType.{{typeName}}) },
                        """
                    );
                    if (seqIdx == seqs.Length - 1 && typeIdx < list.Length - 1)
                        builder.AppendLine();
                }
            }

            // Now, build the DeterministicExecution() function
            builder.AppendLine(
                """
                        };

                        private static string DeterministicExecution(Delegate generator, params object[] arguments)
                        {
                """
            );
            for (int i = 0; i < processedDelegates.Count; i++)
            {
                // Build the clause and get the type
                StringBuilder argsBuilder = new();
                string clause = i == 0 ? "if" : "else if";
                string type = processedDelegates[i];

                // Build the parameter list
                string[] parameters = type.Substring(5, type.Length - 6).Split([", "], StringSplitOptions.None);
                for (int j = 0; j < parameters.Length - 1; j++)
                {
                    string param = parameters[j];
                    string paramClause =
                        param == "string" ? $"arguments[{j}].ToString()" : $"({param})arguments[{j}]";
                    argsBuilder.Append(paramClause);
                    if (j < parameters.Length - 2)
                        argsBuilder.Append(", ");
                }

                // Add the conditional statement to invoke the generator
                builder.AppendLine(
                    $$"""
                                {{clause}} (generator is {{type}} gen{{i}})
                                    return gen{{i}}.Invoke({{argsBuilder}});
                    """
                );
            }

            // Add the footer
            builder.AppendLine(footer);
            context.RegisterPostInitializationOutput(ctx =>
            {
                ctx.AddSource("VtSequenceBuilderTools.g.cs", SourceText.From(builder.ToString(), Encoding.UTF8));
            });
        }
    }
}
