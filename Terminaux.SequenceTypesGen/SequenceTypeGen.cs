//
// Terminaux  Copyright (C) 2023-2024  Aptivi
//
// This file is part of Terminaux
//
// Terminaux is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Terminaux is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY, without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//

using Microsoft.CodeAnalysis;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Terminaux.SequenceTypesGen.Decoy;

namespace Terminaux.SequenceTypesGen
{
    [Generator]
    public class SequenceTypeGen : ISourceGenerator
    {
        public void Execute(GeneratorExecutionContext context)
        {
            // Get the color data content
            var asm = typeof(SequenceTypeGen).Assembly;
            var stream = asm.GetManifestResourceStream($"{asm.GetName().Name}.Resources.sequences.json");
            using var reader = new StreamReader(stream);
            string content = reader.ReadToEnd();

            // Read all the console sequences data
            var list = JsonConvert.DeserializeObject<SequenceTypeInfo[]>(content);
            if (list is null)
                return;
            SequencesGeneralEnumGenerator(list, context);
            SequencesGeneralClassGenerator(list, context);
            SequencesEnumGenerator(list, context);
            SequencesClassGenerator(list, context);
            SequencesDictionaryGenerator(list, context);
            SequencesToolsGenerator(list, context);
        }

        public void Initialize(GeneratorInitializationContext context)
        { }

        private void SequencesGeneralEnumGenerator(SequenceTypeInfo[] list, GeneratorExecutionContext context)
        {
            string header =
                $$"""
                //
                // Terminaux  Copyright (C) 2023-2024  Aptivi
                //
                // This file is part of Terminaux
                //
                // Terminaux is free software: you can redistribute it and/or modify
                // it under the terms of the GNU General Public License as published by
                // the Free Software Foundation, either version 3 of the License, or
                // (at your option) any later version.
                //
                // Terminaux is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY, without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                //
                // You should have received a copy of the GNU General Public License
                // along with this program.  If not, see <https://www.gnu.org/licenses/>.
                //
                
                // <auto-generated/>
                                
                namespace Terminaux.Sequences
                {
                    /// <summary>
                    /// Denotes the VT sequence type
                    /// </summary>
                    public enum VtSequenceType
                    {
                        /// <summary>
                        /// No VT sequences
                        /// </summary>
                        None = 0,
                
                """;
            var builder = new StringBuilder(header);

            // Populate the sequence class for every type
            var masterEnum = new StringBuilder();
            for (int typeIdx = 0; typeIdx < list.Length; typeIdx++)
            {
                SequenceTypeInfo typeInfo = list[typeIdx];
                string typeName = typeInfo.Type;
                string typeNameUpper = typeName.ToUpper();

                // Build the enum values
                builder.AppendLine(
                    $$"""
                            /// <summary>
                            /// {{typeNameUpper}} VT sequences
                            /// </summary>
                            {{typeName}} = {{Math.Pow(2, typeIdx)}},
                    """
                );
                masterEnum.Append(typeName);
                if (typeIdx < list.Length - 1)
                    masterEnum.Append(" + ");
            }

            // Add the footer
            string footer =
                $$"""
                        /// <summary>
                        /// All VT sequences
                        /// </summary>
                        All = {{masterEnum}},
                    }
                }
                """;
            builder.AppendLine(footer);
            context.AddSource($"VtSequenceType.cs", builder.ToString());
        }

        private void SequencesGeneralClassGenerator(SequenceTypeInfo[] list, GeneratorExecutionContext context)
        {
            string header =
                $$"""
                //
                // Terminaux  Copyright (C) 2023-2024  Aptivi
                //
                // This file is part of Terminaux
                //
                // Terminaux is free software: you can redistribute it and/or modify
                // it under the terms of the GNU General Public License as published by
                // the Free Software Foundation, either version 3 of the License, or
                // (at your option) any later version.
                //
                // Terminaux is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY, without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                //
                // You should have received a copy of the GNU General Public License
                // along with this program.  If not, see <https://www.gnu.org/licenses/>.
                //
                
                // <auto-generated/>
                                
                using System.Text.RegularExpressions;

                namespace Terminaux.Sequences
                {
                    /// <summary>
                    /// VT sequence regular expressions
                    /// </summary>
                    public static class VtSequenceRegexes
                    {
                        private static readonly Regex nothingRegex =
                            new(@"\b\B", RegexOptions.Compiled);
                
                """;
            string footer =
                $$"""
                        /// <summary>
                        /// All VT sequences
                        /// </summary>
                        public static Regex AllVTSequences =>
                            allRegex;
                    }
                }
                """;

            // Populate the sequence regexes
            var builder = new StringBuilder(header);
            foreach (var typeInfo in list)
            {
                string typeName = typeInfo.Type;
                string typeNameLower = typeName.ToLower();
                string regex = typeInfo.Regex;

                // Add the private variable declaration
                builder.AppendLine(
                    $$"""
                            private static readonly Regex {{typeNameLower}}Regex =
                                new(@"{{regex}}", RegexOptions.Compiled);
                    """
                );
            }

            // Add a regex for all VT sequences
            var masterRegexBuilder = new StringBuilder();
            for (int i = 0; i < list.Length; i++)
            {
                SequenceTypeInfo typeInfo = list[i];
                string typeName = typeInfo.Type;
                string typeNameUpper = typeName.ToUpper();

                // Add the private variable declaration
                masterRegexBuilder.Append($"{typeNameUpper}Sequences");
                if (i < list.Length - 1)
                    masterRegexBuilder.Append(" + \"|\" + ");
            }
            builder.AppendLine(
                $$"""
                        private static readonly Regex allRegex =
                            new({{masterRegexBuilder}}, RegexOptions.Compiled);

                        /// <summary>
                        /// Match nothing
                        /// </summary>
                        public static Regex Nothing =>
                            nothingRegex;

                """
            );

            // Populate the sequence properties
            foreach (var typeInfo in list)
            {
                string typeName = typeInfo.Type;
                string typeNameLower = typeName.ToLower();
                string typeNameUpper = typeName.ToUpper();

                // Add the private variable declaration
                builder.AppendLine(
                    $$"""
                            /// <summary>
                            /// {{typeNameUpper}} sequences
                            /// </summary>
                            public static Regex {{typeNameUpper}}Sequences =>
                                {{typeNameLower}}Regex;

                    """
                );
            }

            // Add the footer
            builder.AppendLine(footer);
            context.AddSource($"VtSequenceRegexes.cs", builder.ToString());
        }

        private void SequencesEnumGenerator(SequenceTypeInfo[] list, GeneratorExecutionContext context)
        {
            string header =
                $$"""
                //
                // Terminaux  Copyright (C) 2023-2024  Aptivi
                //
                // This file is part of Terminaux
                //
                // Terminaux is free software: you can redistribute it and/or modify
                // it under the terms of the GNU General Public License as published by
                // the Free Software Foundation, either version 3 of the License, or
                // (at your option) any later version.
                //
                // Terminaux is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY, without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                //
                // You should have received a copy of the GNU General Public License
                // along with this program.  If not, see <https://www.gnu.org/licenses/>.
                //
                
                // <auto-generated/>
                                
                namespace Terminaux.Sequences.Builder
                {
                    /// <summary>
                    /// Specific VT sequences sorted by type
                    /// </summary>
                    public enum VtSequenceSpecificTypes
                    {
                
                """;
            string footer =
                $$"""
                    }
                }
                """;
            var builder = new StringBuilder(header);

            // Populate the sequence class for every type
            for (int typeIdx = 0; typeIdx < list.Length; typeIdx++)
            {
                SequenceTypeInfo typeInfo = list[typeIdx];
                string typeNameUpper = typeInfo.Type.ToUpper();
                var seqs = typeInfo.Sequences;

                // Populate the sequence generation methods
                for (int seqIdx = 0; seqIdx < seqs.Length; seqIdx++)
                {
                    Sequence seq = seqs[seqIdx];
                    string seqName = seq.Name;

                    // Build the enum values
                    builder.AppendLine(
                        $$"""
                                /// <summary>
                                /// {{typeNameUpper}} VT sequence ({{seqName}})
                                /// </summary>
                                {{seqName}},
                        """
                    );
                }
            }

            // Add the footer
            builder.AppendLine(footer);
            context.AddSource($"VtSequenceSpecificTypes.cs", builder.ToString());
        }

        private void SequencesClassGenerator(SequenceTypeInfo[] list, GeneratorExecutionContext context)
        {
            string header =
                $$"""
                //
                // Terminaux  Copyright (C) 2023-2024  Aptivi
                //
                // This file is part of Terminaux
                //
                // Terminaux is free software: you can redistribute it and/or modify
                // it under the terms of the GNU General Public License as published by
                // the Free Software Foundation, either version 3 of the License, or
                // (at your option) any later version.
                //
                // Terminaux is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY, without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                //
                // You should have received a copy of the GNU General Public License
                // along with this program.  If not, see <https://www.gnu.org/licenses/>.
                //
                
                // <auto-generated/>
                                
                using System.Text.RegularExpressions;
                using Terminaux.Base;

                namespace Terminaux.Sequences.Builder.Types
                {

                """;
            string footer =
                $$"""
                    }
                }
                """;

            // Populate the sequence class for every type
            foreach (var typeInfo in list)
            {
                var builder = new StringBuilder(header);
                string typeName = typeInfo.Type;
                string typeNameUpper = typeName.ToUpper();
                var seqs = typeInfo.Sequences;

                // Add the class declaration
                builder.AppendLine(
                    $$"""
                        /// <summary>
                        /// List of {{typeNameUpper}} sequences and their regular expressions
                        /// </summary>
                        public static class {{typeName}}Sequences
                        {
                    """
                );

                // Populate the sequence listing (private variables)
                foreach (var seq in seqs)
                {
                    string seqName = seq.Name;
                    string seqNamePrivate = char.ToLower(seqName[0]) + seqName.Substring(1);
                    string seqRegex = seq.Regex;
                    builder.AppendLine(
                        $$"""
                                private static readonly Regex {{seqNamePrivate}}SequenceRegex =
                                    new(@"{{seqRegex}}", RegexOptions.Compiled);
                        """
                    );
                }

                // New line
                builder.AppendLine();

                // Populate the sequence listing (public properties)
                foreach (var seq in seqs)
                {
                    string seqName = seq.Name;
                    string seqNamePrivate = char.ToLower(seqName[0]) + seqName.Substring(1);
                    builder.AppendLine(
                        $$"""
                                /// <summary>
                                /// A regular expression that matches all the VT sequences that are of type {{seqName}}
                                /// </summary>
                                public static Regex {{seqName}}SequenceRegex =>
                                    {{seqNamePrivate}}SequenceRegex;

                        """
                    );
                }

                // Populate the sequence generation methods
                for (int seqIdx = 0; seqIdx < seqs.Length; seqIdx++)
                {
                    Sequence seq = seqs[seqIdx];
                    string seqName = seq.Name;
                    string seqFormat = seq.Format;

                    // Populate the arguments
                    var seqParams = seq.Arguments;
                    var seqParamsBuilder = new StringBuilder();
                    for (int i = 0; i < seqParams.Length; i++)
                    {
                        Argument seqParam = seqParams[i];
                        string name = seqParam.Name;
                        string type =
                            seqParam.Type == "System.Int32" ? "int" :
                            seqParam.Type == "System.Char" ? "char" :
                            "string";
                        seqParamsBuilder.Append($"{type} {name}");
                        if (i < seqParams.Length - 1)
                            seqParamsBuilder.Append(", ");
                        seqFormat = seqFormat.Replace($"{{{{{i}}}}}", $"{{{name}}}");
                    }

                    // Build the generation method
                    builder.AppendLine(
                        $$"""
                                /// <summary>
                                /// Generates an escape sequence of type {{typeNameUpper}} with action {{seqName}}
                                /// </summary>
                                public static string Generate{{seqName}}({{seqParamsBuilder}})
                                {
                                    string result = $"{{seqFormat}}";
                                    var regexParser = {{seqName}}SequenceRegex;
                                    if (!regexParser.IsMatch(result))
                                        throw new TerminauxException($"We have failed to generate a working VT sequence of type {{typeNameUpper}} with action {{seqName}}. Make sure that you've specified values correctly.");
                                    return result;
                                }
                        """
                    );
                    if (seqIdx < seqParams.Length - 1)
                        builder.AppendLine();
                }

                // Add the footer
                builder.AppendLine(footer);
                context.AddSource($"{typeName}Sequences.cs", builder.ToString());
            }
        }

        private void SequencesDictionaryGenerator(SequenceTypeInfo[] list, GeneratorExecutionContext context)
        {
            string header =
                $$"""
                //
                // Terminaux  Copyright (C) 2023-2024  Aptivi
                //
                // This file is part of Terminaux
                //
                // Terminaux is free software: you can redistribute it and/or modify
                // it under the terms of the GNU General Public License as published by
                // the Free Software Foundation, either version 3 of the License, or
                // (at your option) any later version.
                //
                // Terminaux is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY, without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                //
                // You should have received a copy of the GNU General Public License
                // along with this program.  If not, see <https://www.gnu.org/licenses/>.
                //
                
                // <auto-generated/>
                                
                using System;
                using System.Collections.Generic;
                using System.Text.RegularExpressions;
                using Terminaux.Sequences.Builder.Types;

                namespace Terminaux.Sequences.Builder
                {
                    /// <summary>
                    /// VT sequence builder tools
                    /// </summary>
                    public static partial class VtSequenceBuilderTools
                    {
                        private static readonly Dictionary<VtSequenceSpecificTypes, (Delegate generator, Regex matchRegex, int argumentsRequired, VtSequenceType sequenceType)> sequenceBuilders = new()
                        {
                
                """;
            string footer =
                $$"""
                            return generator.DynamicInvoke(arguments).ToString();
                        }
                    }
                }
                """;
            var builder = new StringBuilder(header);
            List<string> processedDelegates = [];

            // Populate the sequence class for every type
            for (int typeIdx = 0; typeIdx < list.Length; typeIdx++)
            {
                SequenceTypeInfo typeInfo = list[typeIdx];
                string typeName = typeInfo.Type;
                string typeNameUpper = typeName.ToUpper();
                var seqs = typeInfo.Sequences;
                builder.AppendLine(
                    $$"""
                                // {{typeNameUpper}} sequences
                    """
                );

                // Populate the sequence generation methods
                for (int seqIdx = 0; seqIdx < seqs.Length; seqIdx++)
                {
                    Sequence seq = seqs[seqIdx];
                    string seqName = seq.Name;

                    // Populate the arguments
                    var seqParams = seq.Arguments;
                    var seqParamsBuilder = new StringBuilder();
                    for (int i = 0; i < seqParams.Length; i++)
                    {
                        Argument seqParam = seqParams[i];
                        string type =
                            seqParam.Type == "System.Int32" ? "int" :
                            seqParam.Type == "System.Char" ? "char" :
                            "string";
                        seqParamsBuilder.Append($"{type}");
                        seqParamsBuilder.Append(", ");
                    }

                    // Build the dictionary entry
                    string processedDelegate = $"Func<{seqParamsBuilder}string>";
                    if (!processedDelegates.Contains(processedDelegate))
                        processedDelegates.Add(processedDelegate);
                    builder.AppendLine(
                        $$"""
                                    { VtSequenceSpecificTypes.{{seqName}},
                                        (new Func<{{seqParamsBuilder}}string>({{typeName}}Sequences.Generate{{seqName}}), {{typeName}}Sequences.{{seqName}}SequenceRegex, {{seqParams.Length}}, VtSequenceType.{{typeName}}) },
                        """
                    );
                    if (seqIdx == seqs.Length - 1 && typeIdx < list.Length - 1)
                        builder.AppendLine();
                }
            }

            // Now, build the DeterministicExecution() function
            builder.AppendLine(
                """
                        };

                        private static string DeterministicExecution(Delegate generator, params object[] arguments)
                        {
                """
            );
            for (int i = 0; i < processedDelegates.Count; i++)
            {
                // Build the clause and get the type
                StringBuilder argsBuilder = new();
                string clause = i == 0 ? "if" : "else if";
                string type = processedDelegates[i];

                // Build the parameter list
                string[] parameters = type.Substring(5, type.Length - 6).Split([", "], StringSplitOptions.None);
                for (int j = 0; j < parameters.Length - 1; j++)
                {
                    string param = parameters[j];
                    string paramClause =
                        param == "string" ? $"arguments[{j}].ToString()" : $"({param})arguments[{j}]";
                    argsBuilder.Append(paramClause);
                    if (j < parameters.Length - 2)
                        argsBuilder.Append(", ");
                }

                // Add the conditional statement to invoke the generator
                builder.AppendLine(
                    $$"""
                                {{clause}} (generator is {{type}} gen{{i}})
                                    return gen{{i}}.Invoke({{argsBuilder}});
                    """
                );
            }

            // Add the footer
            builder.AppendLine(footer);
            context.AddSource($"VtSequenceBuilderTools.g.cs", builder.ToString());
        }

        private void SequencesToolsGenerator(SequenceTypeInfo[] list, GeneratorExecutionContext context)
        {
            string header =
                $$"""
                //
                // Terminaux  Copyright (C) 2023-2024  Aptivi
                //
                // This file is part of Terminaux
                //
                // Terminaux is free software: you can redistribute it and/or modify
                // it under the terms of the GNU General Public License as published by
                // the Free Software Foundation, either version 3 of the License, or
                // (at your option) any later version.
                //
                // Terminaux is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY, without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                //
                // You should have received a copy of the GNU General Public License
                // along with this program.  If not, see <https://www.gnu.org/licenses/>.
                //
                
                // <auto-generated/>
                                
                using System.Text.RegularExpressions;

                namespace Terminaux.Sequences
                {
                    /// <summary>
                    /// Provides all the tools for manipulating with the VT sequences
                    /// </summary>
                    public static partial class VtSequenceTools
                    {
                        /// <summary>
                        /// Gets the sequence filter regular expression from the provided VT sequence <paramref name="type"/> (<see cref="VtSequenceType"/>)
                        /// </summary>
                        /// <param name="type">VT sequence type</param>
                        /// <returns>Regular expression from the provided VT sequence <paramref name="type"/></returns>
                        public static partial Regex GetSequenceFilterRegexFromType(VtSequenceType type)
                        {
                            // Check the enum to get the needed regular expression for the specific type
                            return type switch
                            {
                                VtSequenceType.None => VtSequenceRegexes.Nothing,
                
                """;
            string footer =
                $$"""
                
                                _                   => VtSequenceRegexes.AllVTSequences,
                            };
                        }
                    }
                }
                """;
            var builder = new StringBuilder(header);

            // Populate the sequence class for every type
            for (int typeIdx = 0; typeIdx < list.Length; typeIdx++)
            {
                SequenceTypeInfo typeInfo = list[typeIdx];
                string typeName = typeInfo.Type;
                string typeNameUpper = typeName.ToUpper();

                // Build the enum values
                builder.AppendLine(
                    $$"""
                                    VtSequenceType.{{typeName}}  => VtSequenceRegexes.{{typeNameUpper}}Sequences,
                    """
                );
            }

            // Add the footer
            builder.AppendLine(footer);
            context.AddSource($"VtSequenceTools.g.cs", builder.ToString());
        }
    }
}
